/*
 * SCI_ACCEL.h
 *
 *  Created on: April 29, 2020
 *      Author: Le Truong Thanh
 *      Purpose: Software Command Interface for ACCELEROMETER MMA8652
 *      Comment: DO NOT EDIT THIS FILE
 *      First version for ORANGE DEV BOARD (RAK4200)
 */
#include "SCI_ACCEL.h"
#include "KX003_REGISTER.h"

/*****************************************************************************************************************/
/*													GLOBAL VARIABLES											 */
/*****************************************************************************************************************/

/*****************************************************************************************************************/
/*													   CONSTANT 												 */
/*****************************************************************************************************************/
const AccelRange_t AccelRange[]=
{
		{ 0, 0, 0, 2},
		{ 0, 1, 0, 4},
		{ 1, 0, 0, 8},
		{ 1, 1, 0, 8},
		{ 0, 0, 1, 16},
		{ 0, 1, 1, 16},
		{ 1, 0, 1, 16},
		{ 1, 1, 1, 16},
};

const DataRateWKUP_t DataRateWKUP[]=
{
		{ 0, 0, 0},
		{ 0, 0, 1},
		{ 0, 1, 0},
		{ 0, 1, 1},
		{ 1, 0, 0},
		{ 1, 0, 1},
		{ 1, 1, 0},
		{ 1, 1, 1},
};

const DataRateLPF_t DataRateLPF[]=
{
		{ 1, 0, 0, 0},
		{ 1, 0, 0, 1},
		{ 1, 0, 1, 0},
		{ 1, 0, 1, 1},
		{ 0, 0, 0, 0},
		{ 0, 0, 0, 1},
		{ 0, 0, 1, 0},
		{ 0, 0, 1, 1},
		{ 0, 1, 0, 0},
		{ 0, 1, 0, 1},
		{ 0, 1, 1, 0},
		{ 0, 1, 1, 1},
};

const SensInfomation_t SensInfomation[]=
{
		{ Sens_14bit 	, G8_14bit		, 1024	},
		{ Sens_14bit 	, G16_14bit		, 512	},
		{ Sens_12bit 	, G2 			, 1024	},
		{ Sens_12bit 	, G4 			, 512	},
		{ Sens_12bit 	, G8 			, 256	},
		{ Sens_12bit 	, G16_1			, 128	},
		{ Sens_12bit 	, G16_2			, 128	},
		{ Sens_12bit 	, G16_3			, 128	},
		{ Sens_8bit  	, G2 			, 64	},
		{ Sens_8bit  	, G4 			, 32	},
		{ Sens_8bit  	, G8 			, 16	},
		{ Sens_8bit  	, G16_1			, 8		},
		{ Sens_8bit  	, G16_2			, 8		},
		{ Sens_8bit  	, G16_3			, 8		},
};

/*****************************************************************************************************************/
/*													PRIVATE FUNCTION											 */
/*****************************************************************************************************************/
static void InitAccel(void);

static void Active(void);

static void Standby(void);

static void Reset(void);

static void Sleep(void);

static void MainConfig(void);

static void ExtiCallback(void);

static uint8_t ReadReg(uint8_t adr);

static void WriteReg(uint8_t adr, uint8_t value);

static void SetResolutionMode(ResolutionMode mode);

static void ClearBitReg(uint8_t adr, uint8_t bitnum);

static void SetBitReg(uint8_t adr, uint8_t bitnum);

static void EnableNewAccelINT();

static void DisableNewAccelINT();

static void SetAcceleratorRange(AccelRange_e range);

static void EnableWKUP();

static void DisableWKUP();

static void SetDatarateWKUP(DataRateWKUP_e rating);

static void EnablePhyINT();

static void DisablePhyINT();

static void SetPolarity(Polarity_e pol);

static void SetINTResType(INTResType_e type);

static void SetUnlatchMode(Mode_e mode);

static void SetAxisINTType(Mode_e xneg,Mode_e xpos,Mode_e yneg,Mode_e ypos,Mode_e zneg,Mode_e zpos);

static void SetDatarateLPF(DataRateLPF_e rating);

static void SetWKUPCounter(uint8_t counter);

static void SetNACounter(uint8_t counter);

static void SetWKUPThreshold(float gravity_threshold);

static void SetMode(SensMode_e mode);

static void ReadXYZ(void);
/*****************************************************************************************************************/
/*											APPLICATION PROGRAMMING INTERFACE									 */
/*****************************************************************************************************************/
AccelerationSensorExt Accel={
		.sensibility					= SENSIBILITY_DEFAULT,
		.INT_FLAG						= 0,
		.EXTI_PIN						= INT_PIN,
		.HCI_ACCEL_I2C_INIT				= &HCI_ACCEL_I2C_INIT,
		.HCI_ACCEL_I2C_DEINIT			= &HCI_ACCEL_I2C_DEINIT,
		.HCI_ACCEL_I2C_WRITE			= &HCI_ACCEL_I2C_WRITE,
		.HCI_ACCEL_I2C_READ				= &HCI_ACCEL_I2C_READ,
		.HCI_ACCEL_I2C_CHECK			= &HCI_ACCEL_I2C_CHECK,
		.HCI_ACCEL_GPIO_INIT			= &HCI_ACCEL_GPIO_INIT,
		.HCI_ACCEL_DELAYMS				= &HCI_ACCEL_DELAYMS,
		.SCI_ACCEL_INIT					= &InitAccel,
		.SCI_ACCEL_ACTIVE				= &Active,
		.SCI_ACCEL_STANDBY				= &Standby,
		.SCI_ACCEL_RESET				= &Reset,
		.SCI_ACCEL_MAINCONFIG			= &MainConfig,
		.SCI_ACCEL_EXTI_CALLBACK		= &ExtiCallback,
		.SCI_ACCEL_READXYZ				= &ReadXYZ,
		.SCI_ACCEL_ENABLE_NEW_ACCEL_INT	= &EnableNewAccelINT,
		.SCI_ACCEL_DISABLE_NEW_ACCEL_INT= &DisableNewAccelINT,
		.SCI_ACCEL_ENABLEWKUP			= &EnableWKUP,
		.SCI_ACCEL_DISABLEWKUP			= &DisableWKUP,
		.SCI_ACCEL_SET_DATARATE_WKUP	= &SetDatarateWKUP,
		.SCI_ACCEL_ENBALE_PHYINT		= &EnablePhyINT,
		.SCI_ACCEL_DISABLEPHYINT		= &DisablePhyINT,
		.SCI_ACCEL_SET_POLARITY			= &SetPolarity,
		.SCI_ACCEL_SET_INT_RES_TYPE		= &SetINTResType,
		.SCI_ACCEL_SET_UNLATCH_MODE		= &SetUnlatchMode,
		.SCI_ACCEL_SET_AXIS_INT_TYPE	= &SetAxisINTType,
		.SCI_ACCEL_SET_DATARATE_LPF		= &SetDatarateLPF,
		.SCI_ACCEL_SET_WKUP_COUNTER		= &SetWKUPCounter,
		.SCI_ACCEL_SET_NA_COUNTER		= &SetNACounter,
		.SCI_ACCEL_SET_WKUP_THRESHOLD	= &SetWKUPThreshold
};

/*****************************************************************************************************************/
/*													PRIVATE VARIABLES											 */
/*****************************************************************************************************************/
static uint8_t		REG;

/*****************************************************************************************************************/
/*													FUNCTION IMPLEMENT									 	 	 */
/*****************************************************************************************************************/
void InitAccel(void)
{
	REG=0;

	Accel.HCI_ACCEL_I2C_INIT();
	Accel.HCI_ACCEL_DELAYMS(1);
	Accel.HCI_ACCEL_GPIO_INIT();

	//check device ready state
	while (Accel.HCI_ACCEL_I2C_CHECK(ID)==0) { }

	Accel.SCI_ACCEL_RESET();
	Accel.HCI_ACCEL_DELAYMS(1);
}

void Active(void)
{
	/*REG=ReadReg(CTRL_REG1);
	REG=REG | PC1_MASK;
	WriteReg(CTRL_REG1, REG);*/
	SetBitReg(CTRL_REG1,PC1_BIT);
}

void Standby(void)
{
	/*REG=ReadReg(CTRL_REG1);
	REG=REG & (~PC1_MASK);
	WriteReg(CTRL_REG1, REG);*/
	ClearBitReg(CTRL_REG1,PC1_BIT);
}

void Reset(void)
{
	SetBitReg(CTRL_REG2,SRST_BIT);
	while (ReadReg(CTRL_REG2)&(1<<SRST_BIT)!=0) {};
	Accel.HCI_ACCEL_DELAYMS(1);
}

void ReadXYZ(void)
{
	volatile int16_t tmp=0;
	int8_t res=SensInfomation[Accel.Mode].resolution;
	volatile uint16_t exp=1<<(16-res);
	volatile int8_t low;
	volatile int8_t high;

	high=ReadReg(XOUT_H);
	low=ReadReg(XOUT_L);

	tmp=high*256+low;
	Accel.Axis_T.X_F16=((float)tmp/(float)exp)/(float)SensInfomation[Accel.Mode].count_per_g;


	high=ReadReg(YOUT_H);
	low=ReadReg(YOUT_L);

	tmp=high*256+low;
	Accel.Axis_T.Y_F16=((float)tmp/(float)exp)/(float)SensInfomation[Accel.Mode].count_per_g;


	high=ReadReg(ZOUT_H);
	low=ReadReg(ZOUT_L);

	tmp=high*256+low;
	Accel.Axis_T.Z_F16=((float)tmp/(float)exp)/(float)SensInfomation[Accel.Mode].count_per_g;

}

void ExtiCallback(void)
{
	Accel.INT_FLAG=1;
	ReadXYZ();
	ReadReg(INT_REL);
}

uint8_t ReadReg(uint8_t adr)
{
	uint8_t data=0xFF;
	Accel.HCI_ACCEL_I2C_READ(adr,&data,1);
	return data;
}

void WriteReg(uint8_t adr, uint8_t value)
{
	Accel.HCI_ACCEL_I2C_WRITE(adr,value);
}

void SetResolutionMode(ResolutionMode mode)
{
	Accel.SCI_ACCEL_STANDBY();
	if (mode==LOW_POWER)
		ClearBitReg(CTRL_REG1,RES_BIT);
	else
		SetBitReg(CTRL_REG1,RES_BIT);
	Accel.SCI_ACCEL_ACTIVE();
}

void ClearBitReg(uint8_t adr, uint8_t bitnum)
{
	REG=ReadReg(adr);
	REG=REG & (~(1<<bitnum));
	WriteReg(adr, REG);
}

void SetBitReg(uint8_t adr, uint8_t bitnum)
{
	REG=ReadReg(adr);
	REG=REG | (1<<bitnum);
	WriteReg(adr, REG);
}

void EnableNewAccelINT()
{
	Accel.SCI_ACCEL_STANDBY();
	SetBitReg(CTRL_REG1,DRDYE_BIT);
	Accel.SCI_ACCEL_ACTIVE();
}

void DisableNewAccelINT()
{
	Accel.SCI_ACCEL_STANDBY();
	ClearBitReg(CTRL_REG1,DRDYE_BIT);
	Accel.SCI_ACCEL_ACTIVE();
}

void SetAcceleratorRange(AccelRange_e range)
{
	Accel.SCI_ACCEL_STANDBY();
	AccelRange_t tmp=AccelRange[range];
	REG=ReadReg(CTRL_REG1);
	REG=REG & (~(1<<GSEL1_BIT)) & (~(1<<GSEL0_BIT)) & (~(1<<EN16G_BIT));
	REG=REG | (tmp.GSEL1<<GSEL1_BIT) | (tmp.GSEL0 << GSEL0_BIT) | (tmp.EN16G << EN16G_BIT);
	WriteReg(CTRL_REG1,REG);
	Accel.SCI_ACCEL_ACTIVE();
}

void EnableWKUP()
{
	Accel.SCI_ACCEL_STANDBY();
	SetBitReg(CTRL_REG1,WUFE_BIT);
	Accel.SCI_ACCEL_ACTIVE();
}

void DisableWKUP()
{
	Accel.SCI_ACCEL_STANDBY();
	ClearBitReg(CTRL_REG1,WUFE_BIT);
	Accel.SCI_ACCEL_ACTIVE();
}

void SetDatarateWKUP(DataRateWKUP_e rating)
{
	Accel.SCI_ACCEL_STANDBY();
	DataRateWKUP_t tmp=DataRateWKUP[rating];
	REG=ReadReg(CTRL_REG2);
	REG=REG & (~(1<<OWUFA_BIT)) & (~(1<<OWUFB_BIT)) & (~(1<<OWUFC_BIT));
	REG=REG | (tmp.OWUFA<<OWUFA_BIT) | (tmp.OWUFB << OWUFB_BIT) | (tmp.OWUFC << OWUFC_BIT);
	WriteReg(CTRL_REG2,REG);
	Accel.SCI_ACCEL_ACTIVE();
}

void EnablePhyINT()
{
	Accel.SCI_ACCEL_STANDBY();
	SetBitReg(INT_CTRL_REG1,IEN_BIT);
	Accel.SCI_ACCEL_ACTIVE();
}

void DisablePhyINT()
{
	Accel.SCI_ACCEL_STANDBY();
	ClearBitReg(INT_CTRL_REG1,IEN_BIT);
	Accel.SCI_ACCEL_ACTIVE();
}

void SetPolarity(Polarity_e pol)
{
	Accel.SCI_ACCEL_STANDBY();
	if (pol==POLARITY_LOW)
		ClearBitReg(INT_CTRL_REG1,IEA_BIT);
	else
		SetBitReg(INT_CTRL_REG1,IEA_BIT);
	Accel.SCI_ACCEL_ACTIVE();
}

void SetINTResType(INTResType_e type)
{
	Accel.SCI_ACCEL_STANDBY();
	if (type==LATCH)
		ClearBitReg(INT_CTRL_REG1,IEL_BIT);
	else
		SetBitReg(INT_CTRL_REG1,IEL_BIT);
	Accel.SCI_ACCEL_ACTIVE();
}

void SetUnlatchMode(Mode_e mode)
{
	Accel.SCI_ACCEL_STANDBY();
	if (mode==MODE_DISABLE)
		ClearBitReg(INT_CTRL_REG2,ULMODE_BIT);
	else
		SetBitReg(INT_CTRL_REG2,ULMODE_BIT);
	Accel.SCI_ACCEL_ACTIVE();
}

void SetAxisINTType(Mode_e xneg,Mode_e xpos,Mode_e yneg,Mode_e ypos,Mode_e zneg,Mode_e zpos)
{
	Accel.SCI_ACCEL_STANDBY();
	uint8_t tmp=0;
	tmp|=xneg<<XNWU_BIT;
	tmp|=xpos<<XPWU_BIT;
	tmp|=yneg<<YNWU_BIT;
	tmp|=ypos<<YPWU_BIT;
	tmp|=zneg<<ZNWU_BIT;
	tmp|=zpos<<ZPWU_BIT;

	uint8_t mask=0xFF;
	mask&=~(1<<XNWU_BIT);
	mask&=~(1<<XPWU_BIT);
	mask&=~(1<<YNWU_BIT);
	mask&=~(1<<YPWU_BIT);
	mask&=~(1<<ZNWU_BIT);
	mask&=~(1<<ZPWU_BIT);

	REG=ReadReg(INT_CTRL_REG2);
	REG&=mask;
	REG|=tmp;

	WriteReg(INT_CTRL_REG2,REG);
	Accel.SCI_ACCEL_ACTIVE();
}

void SetDatarateLPF(DataRateLPF_e rating)
{
	Accel.SCI_ACCEL_STANDBY();
	DataRateLPF_t tmp = DataRateLPF[rating];
	REG=ReadReg(DATA_CTRL_REG);
	REG=REG & (~(1<<OSAA_BIT)) & (~(1<<OSAB_BIT)) & (~(1<<OSAC_BIT)) & (~(1<<OSAD_BIT));
	REG=REG | (tmp.OSAA<<OSAA_BIT) | (tmp.OSAB<<OSAB_BIT) | (tmp.OSAC<<OSAC_BIT) | (tmp.OSAD<<OSAD_BIT);
	WriteReg(DATA_CTRL_REG,REG);
	Accel.SCI_ACCEL_ACTIVE();
}

void SetWKUPCounter(uint8_t counter)
{
	Accel.SCI_ACCEL_STANDBY();
	WriteReg(WAKEUP_COUNTER,counter);
	Accel.SCI_ACCEL_ACTIVE();
}

void SetNACounter(uint8_t counter)
{
	Accel.SCI_ACCEL_STANDBY();
	WriteReg(NA_COUNTER,counter);
	Accel.SCI_ACCEL_ACTIVE();
}

void SetWKUPThreshold(float gravity_threshold)
{
	Accel.SCI_ACCEL_STANDBY();
	uint16_t threshold = gravity_threshold*256;
	if (threshold>=(1<<13))
		return;
	threshold=threshold<<4;
	uint8_t t_h=(threshold>>8)&0xFF;
	uint8_t t_l=threshold&0xF0;
	WriteReg(WAKEUP_THRESHOLD_H,t_h);
	WriteReg(WAKEUP_THRESHOLD_L,t_l);
	Accel.SCI_ACCEL_ACTIVE();
}

void SetMode(SensMode_e mode)
{
	Accel.Mode=mode;
	SetAcceleratorRange(SensInfomation[mode].gravity_range);
	SetResolutionMode(SensInfomation[mode].resolution);
}

void MainConfig()
{
	InitAccel();
	//Set defualt resolution and range
	SetMode(BIT8_G2);
	SetDatarateWKUP(DR6_25);
	SetDatarateLPF(DR6_25__LPF3_125);

	EnableWKUP();
	SetAxisINTType(MODE_ENABLE,MODE_ENABLE,MODE_ENABLE,MODE_ENABLE,MODE_ENABLE,MODE_ENABLE);

	SetUnlatchMode(MODE_DISABLE);
	SetINTResType(LATCH);

	SetPolarity(POLARITY_HIGH);

	SetWKUPThreshold(0.5);
	SetWKUPCounter(0);

	EnablePhyINT();
}
